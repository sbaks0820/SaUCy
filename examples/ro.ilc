data Msg = Commit Bit | Committed | Open | Opened Bit | Receipt | Failed
data Msg' = P2RO a | Commit' [Bit] | Open' [Bit]
data Crupt = CruptP | CruptQ | CruptNone
data Z2A = A2F a | A2P a | X2Z a
data A2P = P2Q a | P2F a
data Bit = Z | S
data Back = IsIn a | Add a b

let xor a b = if a == b then Z else S
let xors as bs =
  map (lam x . let (a,b) = x in xor a b) (zip as bs)

letrec splitbits5 bits =
  match bits with
  | b1:b2:b3:b4:b5:bs => (match splitbits5 bs with
                       | (bs1,bs2,bs3,bs4,bs5) => (b1:bs1,b2:bs2,b3:bs3,b4:bs4,b5:bs5))
  | _                 => ([],[],[],[],[])

letrec isin x assoc =
  match assoc with
  | []                     => false
  | (k,v):rest when x == k => true
  | _:rest                 => isin x rest

letrec loop f frS = let (!v, frS) = rd frS in f v ; loop f frS
letrec loop2 table f frS =
  let (!v, frS) = rd frS in let table = f v table in loop2 table f frS

letrec fwd toR frS =
  let (!msg, frS) = rd frS in wr msg -> toR; fwd toR frS

letrec cruptfwd toP toF frS =
  let (!msg, frS) = rd frS in
    match msg with
    | P2F m => wr m -> toF; cruptfwd toP toF frS
    | P2Q m => wr m -> toP; cruptfwd toP toF frS

{-
   a shared mutable table. ILC doesn't support mutable stores yet
   so a separate process is needed to implement a shared table
   where the functionality sends it queries and receives answers
-}
let atable k bits rF2T wF2T rT2F wT2F =
    loop2 [] ( lam x . lam tt . if (isin x tt) then 
                               {-print "[F_ro] true";-}
                               let h = lookup x tt in
                                 wr h -> wT2F;
                                 tt
                             else
                               {-print "[F_ro] false"; print "[F_ro] table"; print tt; -}
                               let (h,bits) = splitAt k bits in
                                 {-print "[F_ro] h"; print h; print "[F_ro] bits"; print bits;-}
                                 let tt = (x,h) : tt in
                                   wr h -> wT2F;
                                   tt ) rF2T

{- 
    Random Oracle Functionality 
-}
let funcro k bits crupt toP toQ toA frP frQ frA = 
  nu (rF2T, wF2T), (rT2F, wT2F) .
  let query = lam () . lam fr . lam to .
    	loop (lam x .
          wr x -> wF2T;
          let (!h, rT2F) = rd rT2F in
            wr h -> to) fr in ()
      |> atable k bits rF2T wF2T rT2F wT2F
      |> query () frP toP
      |> query () frQ toQ
      |> query () frA toA
      |> ()

{- 
   Commitment functionality
-}
let fCom k bits crupt toP toQ toA frP frQ frA =
  let (!(Commit b), frP) = rd frP in
    wr Committed -> toQ;
      let (!Open, frP) = rd frP in
        wr (Opened b) -> toQ

{-
  Wrapper for parties
-}
let corruptOrNot p k bits iscrupt toZ toF toA toQ frZ frF frA frQ = 
  if iscrupt then ()
    |> fwd toA frF
    |> fwd toA frQ
    |> cruptfwd toQ toF frA
  else
    p k bits CruptNone toZ toF toQ frZ frF frQ


let idealparty k bits crupt toZ toF toP frZ frF frP =
  ()
  |> fwd toF frZ
  |> fwd toZ frF

{-
  Protocol commitment 
-}
let committer k bits crupt toZ toF toQ frZ frF frQ = 
  let (!(Commit b), frZ) = rd frZ in
    let (nonce, bits) = splitAt k bits in
    {-print "[Sender] sender nonce"; print nonce;-}
    wr (P2RO (nonce, b)) -> toF;
      let (!h, frF) = rd frF in
        {-print "[Sender] hello"; print h;-}
        wr (Commit' h) -> toQ;
        let (!Open, frZ) = rd frZ in
          {-print "Got open from Z, sending over";-}
          {-print (nonce, b);-}
          wr (Open' (nonce,b)) -> toQ; ()

let receiver k bits crupt toZ toF toP frZ frF frP =
  let (!(Commit' h), frP) = rd frP in
    wr Committed -> toZ;
    let (!(Open' m), frP) = rd frP in
      let (nonce, b) = m in
        wr (P2RO (nonce, b)) -> toF;
        let (!hh, frF) = rd frF in
          if (h == hh) then 
            wr (Opened b) -> toZ; ()
          else
            wr (Opened b) -> toZ; ()

let exec2 k bits toP toQ toA frP frQ frA =
  wr (Commit Z) -> toP;
  let (!Committed, frQ) = rd frQ in
    wr Open -> toP;
      let (!(Opened b), frQ) = rd frQ in
        print "Opened"; print b; ()

let dummyA k bits crupt toZ toF toP toQ frZ frF frP frQ =
  let fwd2Z = lam () . lam c . loop (lam m . wr (X2Z m) -> toZ) c in
    loop (lam x . match x with
      | A2F m => wr m -> toF
      | A2P m => if crupt == CruptP
                 then wr m -> toP
                 else error "can't do that") frZ
    |> fwd2Z () frF
    |> fwd2Z () frP
    |> fwd2Z () frQ

let pcrupt k bits frA toP =
  let (!(P2Q (Commit' h)), frA) = rd frA in
    let (bf,bits) = splitAt 1 bits in
      let b = head bf in
        wr P2F (Commit b) -> toP;
          let (!(P2Q( Open' h)), frA) = rd frA in
            wr P2F Open -> toP; ()

let qcrupt k bits frA toZ =
  let (!Committed, frA) = rd frA in
    let (hh, bits) = splitAt k bits in
      wr (Commit' hh) -> toZ;
        let (!(Opened b), frA) = rd frA in
          let (junk, bits) = sampleAt k bits in
            wr Open' (junk,b) -> toZ; ()

let simCom k bits crupt toZ toF toP toQ frZ frF frP frQ =
  nu (rA2S,wA2S), (rF2R,wF2R), (rF2S,wF2S),
     (rS2T,wS2T), (rT2S,wT2S) .
  let query = lam () . lam fr . lam to .
    	loop (lam x .
          wr x -> wS2T;
          let (!h, rT2S) = rd rT2S in
            wr h -> to) fr in ()
  |> atable k bits rS2T wS2T rT2S wT2S 
  |> loop (lam x . match x with
             | A2P m => wr m -> wA2S
             | A2F m => wr m -> wS2T; 
                        let (!h, rT2S) = rd rT2S in
                          wr (X2Z h) -> toZ ) frZ
  |> loop (lam x . wr x -> wF2S ) frP
  |> loop (lam x . wr x -> wF2R ) frQ
  |> if crupt==CruptP then
       pcrupt k bits rA2S toP
     else if crupt==CruptQ then
       qcrupt k bits rF2R toZ 
     else ()
       
let execcrupt k bits toP toQ toA frP frQ frA  =
  let b = Z in
  let (nonce, bits) = splitAt k bits in
    wr A2F (P2RO (nonce, b)) -> toA;
    let (!(X2Z h), frA) = rd frA in
      wr A2P (P2Q (Commit' h)) -> toA;
        let (!Committed, frQ) = rd frQ in
          wr A2P (P2Q (Open' (nonce,b))) -> toA;
           let (!(Opened bb), frQ) = rd frQ in
             print "Opened"; print bb; ()


let thebits = [Z,S,Z,S,S,Z,S,Z,Z,S,Z,S,Z,S,Z,Z,S,Z,S,Z,Z,S,Z,S,S]
let maincrupt () =
  nu (rZ2P,wZ2P), (rP2Z,wP2Z),
     (rZ2Q,wZ2Q), (rQ2Z,wQ2Z),
     (rP2F,wP2F), (rF2P,wF2P),
     (rQ2F,wQ2F), (rF2Q,wF2Q),
     (rP2Q,wP2Q), (rQ2P,wQ2P),
     (rF2A,wF2A), (rA2F,wA2F),
     (rP2A,wP2A), (rA2P,wA2P),
     (rQ2A,wQ2A), (rA2Q,wA2Q),
     (rZ2A,wZ2A), (rA2Z,wA2Z),
     (rtoQasP,wtoQasP), (rtoPasQ,wtoPasQ) . 
  print "Initialized";
  let (rz,rp,rq,rf,ra) = splitbits5 thebits in ()
  |> corruptOrNot committer 4 rp false wP2Z wP2F wP2A wP2Q rZ2P rF2P rA2P rQ2P
  |> corruptOrNot receiver 4 rq false wQ2Z wQ2F wQ2A wQ2P rZ2Q rF2Q rA2Q rP2Q
  |> funcro 4 rf CruptNone wF2P wF2Q wF2A rP2F rQ2F rA2F
  |> dummyA 4 ra CruptNone wA2Z wA2F wA2P wA2Q rZ2A rF2A rP2A rQ2A
  |> exec2 4 rz wZ2P wZ2Q wZ2A rP2Z rQ2Z rA2Z


let execUC z p q f a crupt k r =
  nu (rZ2P, wZ2P), (rP2Z, wP2Z),
     (rZ2Q, wZ2Q), (rQ2Z, wQ2Z),
     (rP2F, wP2F), (rF2P, wF2P),
     (rQ2F, wQ2F), (rF2Q, wF2Q),
     (rF2A, wF2A), (rA2F, wA2F),
     (rA2Z, wA2Z), (rZ2A, wZ2A),
     (rP2A, wP2A), (rA2P, wA2P),
     (rQ2A, wQ2A), (rA2Q, wA2Q),
     (rP2Q, wP2Q), (rQ2P, wQ2P)
   . let (rf, ra, rp, rq, rz) = splitbits5 thebits in ()
     |> f k rf crupt wF2P wF2Q wF2A rP2F rQ2F rA2F
     |> a k ra crupt wA2Z wA2F wA2P wA2Q rZ2A rF2A rP2A rQ2A
     |> corruptOrNot p k rp (crupt==CruptP) wP2Z wP2F wP2A wP2Q rZ2P rF2P rA2P rQ2P
     |> corruptOrNot q k rq (crupt==CruptQ) wQ2Z wQ2F wQ2A wQ2P rZ2Q rF2Q rA2Q rP2Q
     |> z k rz wZ2P wZ2Q wZ2A rP2Z rQ2Z rA2Z

let main1 () =
  execUC (execcrupt) (idealparty) (idealparty) (fCom) (simCom) (CruptP) 4 thebits

let main2 () =
  execUC (execcrupt) (committer) (receiver) (funcro) (dummyA) (CruptP) 4 thebits

